import*as t from"rematrix";const e=t=>"number"==typeof t,i=t=>"function"==typeof t,n=t=>"[object Object]"===Object.prototype.toString.call(t),s=t=>Array.prototype.slice.apply(t),r=t=>{const e=t.reduce((t,e)=>(t[e]=(t[e]||0)+1,t),{});return Object.keys(e).filter(t=>e[t]>1)};function a(t,...e){return e.forEach(e=>{if(e)for(const i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])}),t}const o=(t,e,i)=>t+(e-t)*i;var l={__proto__:null,isNumber:e,isFunction:i,isObject:n,toArray:s,getDuplicateValsAsStrings:r,assign:a,tweenProp:o};const p="data-flip-id",d="data-inverse-flip-id",h="data-portal-key",c="data-exit-container";var g={__proto__:null,DATA_FLIP_ID:p,DATA_INVERSE_FLIP_ID:d,DATA_FLIP_COMPONENT_ID:"data-flip-component-id",DATA_FLIP_CONFIG:"data-flip-config",DATA_PORTAL_KEY:h,DATA_EXIT_CONTAINER:c};const f={noWobble:{stiffness:200,damping:26},gentle:{stiffness:120,damping:14},veryGentle:{stiffness:130,damping:17},wobbly:{stiffness:180,damping:12},stiff:{stiffness:260,damping:26}},m=t=>n(t)?t:Object.keys(f).indexOf(t)>-1?f[t]:{};let u;"undefined"!=typeof window&&(u=window.requestAnimationFrame),u=u||function(t){window.setTimeout(t,1e3/60)};var y=u;const _=Date.now(),S="object"==typeof performance&&"function"==typeof performance.now?()=>performance.now():()=>Date.now()-_;function v(t,e){const i=t.indexOf(e);-1!==i&&t.splice(i,1)}class E{run(){y(()=>{this.springSystem.loop(S())})}}class A{constructor(){this.position=0,this.velocity=0}}let C=0;const b=.001;class I{constructor(t){this._id="s"+C++,this._springSystem=t,this.listeners=[],this._startValue=0,this._currentState=new A,this._displacementFromRestThreshold=.001,this._endValue=0,this._overshootClampingEnabled=!1,this._previousState=new A,this._restSpeedThreshold=.001,this._tempState=new A,this._timeAccumulator=0,this._wasAtRest=!0,this._cachedSpringConfig={}}getId(){return this._id}destroy(){this.listeners=[],this._springSystem.deregisterSpring(this)}setSpringConfig(t){return this._springConfig=t,this}getCurrentValue(){return this._currentState.position}getDisplacementDistanceForState(t){return Math.abs(this._endValue-t.position)}setEndValue(t){if(t===this._endValue)return this;if(this.prevEndValue=t,this._endValue===t&&this.isAtRest())return this;this._startValue=this.getCurrentValue(),this._endValue=t,this._springSystem.activateSpring(this.getId());for(let t=0,e=this.listeners.length;t<e;t++){const e=this.listeners[t].onSpringEndStateChange;e&&e(this)}return this}setVelocity(t){return t===this._currentState.velocity||(this._currentState.velocity=t,this._springSystem.activateSpring(this.getId())),this}setCurrentValue(t){this._startValue=t,this._currentState.position=t;for(var e=0,i=this.listeners.length;e<i;e++){var n=this.listeners[e];n.onSpringUpdate&&n.onSpringUpdate(this)}return this}setAtRest(){return this._endValue=this._currentState.position,this._tempState.position=this._currentState.position,this._currentState.velocity=0,this}setOvershootClampingEnabled(t){return this._overshootClampingEnabled=t,this}isOvershooting(){const t=this._startValue,e=this._endValue;return this._springConfig.tension>0&&(t<e&&this.getCurrentValue()>e||t>e&&this.getCurrentValue()<e)}advance(t,e){let i=this.isAtRest();if(i&&this._wasAtRest)return;let n=e;e>.064&&(n=.064),this._timeAccumulator+=n;const s=this._springConfig.tension,r=this._springConfig.friction;let a,o,l,p,d,h,c,g,f,m,u=this._currentState.position,y=this._currentState.velocity,_=this._tempState.position,S=this._tempState.velocity;for(;this._timeAccumulator>=b;)this._timeAccumulator-=b,this._timeAccumulator<b&&(this._previousState.position=u,this._previousState.velocity=y),a=y,o=s*(this._endValue-_)-r*y,_=u+a*b*.5,S=y+o*b*.5,l=S,p=s*(this._endValue-_)-r*S,_=u+l*b*.5,S=y+p*b*.5,d=S,h=s*(this._endValue-_)-r*S,_=u+d*b,S=y+h*b,c=S,g=s*(this._endValue-_)-r*S,f=1/6*(a+2*(l+d)+c),m=1/6*(o+2*(p+h)+g),u+=f*b,y+=m*b;this._tempState.position=_,this._tempState.velocity=S,this._currentState.position=u,this._currentState.velocity=y,this._timeAccumulator>0&&this._interpolate(this._timeAccumulator/b),(this.isAtRest()||this._overshootClampingEnabled&&this.isOvershooting())&&(this._springConfig.tension>0?(this._startValue=this._endValue,this._currentState.position=this._endValue):(this._endValue=this._currentState.position,this._startValue=this._endValue),this.setVelocity(0),i=!0);let v=!1;this._wasAtRest&&(this._wasAtRest=!1,v=!0);let E=!1;i&&(this._wasAtRest=!0,E=!0),this.notifyPositionUpdated(v,E)}notifyPositionUpdated(t,e){this.listeners.filter(Boolean).forEach(i=>{t&&i.onSpringActivate&&!this._onActivateCalled&&(i.onSpringActivate(this),this._onActivateCalled=!0),i.onSpringUpdate&&i.onSpringUpdate(this),e&&i.onSpringAtRest&&i.onSpringAtRest(this)})}systemShouldAdvance(){return!this.isAtRest()||!this.wasAtRest()}wasAtRest(){return this._wasAtRest}isAtRest(){return Math.abs(this._currentState.velocity)<this._restSpeedThreshold&&(this.getDisplacementDistanceForState(this._currentState)<=this._displacementFromRestThreshold||0===this._springConfig.tension)}_interpolate(t){this._currentState.position=this._currentState.position*t+this._previousState.position*(1-t),this._currentState.velocity=this._currentState.velocity*t+this._previousState.velocity*(1-t)}addListener(t){return this.listeners.push(t),this}addOneTimeListener(t){const e=e=>(...i)=>{e(...i),this.removeListener(t)};return Object.keys(t).forEach(i=>{t[i]=e(t[i])}),this.listeners.push(t),this}removeListener(t){return v(this.listeners,t),this}}class w{constructor(t){this.looper=t||new E,this.looper.springSystem=this,this.listeners=[],this._activeSprings=[],this._idleSpringIndices=[],this._isIdle=!0,this._lastTimeMillis=-1,this._springRegistry={}}createSpring(t,e){return this.createSpringWithConfig({tension:t,friction:e})}createSpringWithConfig(t){const e=new I(this);return this.registerSpring(e),e.setSpringConfig(t),e}getIsIdle(){return this._isIdle}registerSpring(t){this._springRegistry[t.getId()]=t}deregisterSpring(t){v(this._activeSprings,t),delete this._springRegistry[t.getId()]}advance(t,e){for(;this._idleSpringIndices.length>0;)this._idleSpringIndices.pop();for(this._activeSprings.filter(Boolean).forEach(i=>{i.systemShouldAdvance()?i.advance(t/1e3,e/1e3):this._idleSpringIndices.push(this._activeSprings.indexOf(i))});this._idleSpringIndices.length>0;){const t=this._idleSpringIndices.pop();t>=0&&this._activeSprings.splice(t,1)}}loop(t){let e;-1===this._lastTimeMillis&&(this._lastTimeMillis=t-1);const i=t-this._lastTimeMillis;this._lastTimeMillis=t;let n=0;const s=this.listeners.length;for(n=0;n<s;n++)e=this.listeners[n],e.onBeforeIntegrate&&e.onBeforeIntegrate(this);for(this.advance(t,i),0===this._activeSprings.length&&(this._isIdle=!0,this._lastTimeMillis=-1),n=0;n<s;n++)e=this.listeners[n],e.onAfterIntegrate&&e.onAfterIntegrate(this);this._isIdle||this.looper.run()}activateSpring(t){const e=this._springRegistry[t];-1===this._activeSprings.indexOf(e)&&this._activeSprings.push(e),this.getIsIdle()&&(this._isIdle=!1,this.looper.run())}}const O=new w,x=t=>{const{springConfig:{stiffness:e,damping:i,overshootClamping:n},getOnUpdateFunc:s,onAnimationEnd:r,onSpringActivate:a}=t,o=O.createSpring(e,i);o.setOvershootClampingEnabled(!!n);const l={onSpringActivate:a,onSpringAtRest:()=>{o.destroy(),r()},onSpringUpdate:s({spring:o,onAnimationEnd:r})};return o.addListener(l),o},U=t=>{const e=x(t);return e.setEndValue(1),e},V=(t,e={})=>{if(!t||!t.length)return;e.reverse&&t.reverse();const i="number"!=typeof(n=e.speed)?1.1:1+Math.min(Math.max(5*n,0),5);var n;const s=1/Math.max(Math.min(t.length,100),10),r=t.map((t,e)=>{const n=t.getOnUpdateFunc;return t.getOnUpdateFunc=t=>{const a=n(t);return t=>{let n=t.getCurrentValue();n=n<.01?0:n>.99?1:n,n>=s&&r[e+1]&&r[e+1](Math.max(Math.min(n*i,1),0)),a(t)}},t}).map(t=>{const e=x(t);if(e)return e.setEndValue.bind(e)}).filter(Boolean);r[0]&&r[0](1)},F=t=>[0,1,4,5,12,13].map(e=>t[e]),P=({top:t,bottom:e,left:i,right:n})=>t<window.innerHeight&&e>0&&i<window.innerWidth&&n>0;function D(t){return JSON.parse(t.dataset.flipConfig||"{}")}const R=(t,e)=>a(t,{[e[0]]:e[1]}),T=(t,e)=>s(e?document.querySelectorAll(`[${h}="${e}"]`):t.querySelectorAll(`[${p}]`)),M=t=>t.map(t=>[t,t.getBoundingClientRect()]),k=({cachedOrderedFlipIds:n=[],inProgressAnimations:l={},flippedElementPositionsBeforeUpdate:c={},flipCallbacks:g={},containerEl:u,applyTransformOrigin:y,spring:_,debug:S,portalKey:v,staggerConfig:E={},decisionData:A={},handleEnterUpdateDelete:C,onComplete:b,onStart:I})=>{if(window.matchMedia("(prefers-reduced-motion: reduce)").matches)return;const w=(({element:t,portalKey:e})=>M(T(t,e)).map(([t,e])=>{const i=window.getComputedStyle(t);return[t.dataset.flipId,{element:t,rect:e,opacity:parseFloat(i.opacity),transform:i.transform}]}).reduce(R,{}))({element:u,portalKey:v}),O=(({containerEl:t,portalKey:e})=>e?(t=>e=>s(document.querySelectorAll(`[${h}="${t}"]${e}`)))(e):t?(t=>{const e=Math.random().toFixed(5);return t.dataset.flipperId=e,i=>s(t.querySelectorAll(`[data-flipper-id="${e}"] ${i}`))})(t):()=>[])({containerEl:u,portalKey:v}),x=(t=>e=>t(`[${p}="${e}"]`)[0])(O),k=t=>c[t]&&w[t],$=Object.keys(c).concat(Object.keys(w)).filter(t=>!k(t)),j={flipCallbacks:g,getElement:x,flippedElementPositionsBeforeUpdate:c,flippedElementPositionsAfterUpdate:w,inProgressAnimations:l,decisionData:A},B=a({},j,{unflippedIds:$}),{hideEnteringElements:N,animateEnteringElements:L,animateExitingElements:q}=(({unflippedIds:t,flipCallbacks:e,getElement:i,flippedElementPositionsBeforeUpdate:n,flippedElementPositionsAfterUpdate:s,inProgressAnimations:r,decisionData:a})=>{const o=t.filter(t=>s[t]).filter(t=>e[t]&&e[t].onAppear),l=t.filter(t=>n[t]&&e[t]&&e[t].onExit);let p;const d=new Promise(t=>{p=t}),h=[];let c=0;const g=l.map((t,i)=>{const{domDataForExitAnimations:{element:s,parent:o,childPosition:{top:l,left:d,width:g,height:f}}}=n[t];"static"===getComputedStyle(o).position&&(o.style.position="relative"),s.style.transform="matrix(1, 0, 0, 1, 0, 0)",s.style.position="absolute",s.style.top=l+"px",s.style.left=d+"px",s.style.height=f+"px",s.style.width=g+"px";let m=h.filter(t=>t[0]===o)[0];m||(m=[o,document.createDocumentFragment()],h.push(m)),m[1].appendChild(s),c+=1;const u=()=>{try{o.removeChild(s)}catch(t){}finally{c-=1,0===c&&p()}};return r[t]={stop:u},()=>e[t].onExit(s,i,u,a)});return h.forEach(t=>{t[0].appendChild(t[1])}),g.length||p(),{hideEnteringElements:()=>{o.forEach(t=>{const e=i(t);e&&(e.style.opacity="0")})},animateEnteringElements:()=>{o.forEach((t,n)=>{const s=i(t);s&&e[t].onAppear(s,n,a)})},animateExitingElements:()=>(g.forEach(t=>t()),d)}})(B),X=a({},j,{containerEl:u,flippedIds:n.filter(k),applyTransformOrigin:y,spring:_,debug:S,staggerConfig:E,scopedSelector:O,onComplete:b});I&&I(u,A);const Y=(({flippedIds:n,flipCallbacks:l,inProgressAnimations:p,flippedElementPositionsBeforeUpdate:h,flippedElementPositionsAfterUpdate:c,applyTransformOrigin:g,spring:u,getElement:y,debug:_,staggerConfig:S={},decisionData:v={},onComplete:E,containerEl:A})=>{let C;const b=new Promise(t=>{C=t});if(E&&b.then(()=>E(A,v)),!n.length)return()=>(C([]),b);const I=[],w=y(n[0]),O=w?w.ownerDocument.querySelector("body"):document.querySelector("body");r(n);const x=n.map(n=>{const r=h[n].rect,y=c[n].rect,_=h[n].opacity,S=c[n].opacity,E=y.width<1||y.height<1,A=c[n].element;if(!P(r)&&!P(y))return!1;if(!A)return!1;const b=D(A),w=(({flipperSpring:t,flippedSpring:e}={})=>a({},f.noWobble,m(t),m(e)))({flipperSpring:u,flippedSpring:b.spring}),U=!0===b.stagger?"default":b.stagger,V={element:A,id:n,stagger:U,springConfig:w};if(l[n]&&l[n].shouldFlip&&!l[n].shouldFlip(v.previous,v.current))return!1;const R=Math.abs(r.left-y.left)+Math.abs(r.top-y.top),T=Math.abs(r.width-y.width)+Math.abs(r.height-y.height),M=Math.abs(S-_);if(0===r.height&&0===y.height||0===r.width&&0===y.width||R<.5&&T<.5&&M<.01)return!1;const k=t.parse(c[n].transform),$={matrix:k},j={matrix:[]},B=[k];b.translate&&(B.push(t.translateX(r.left-y.left)),B.push(t.translateY(r.top-y.top))),b.scale&&(B.push(t.scaleX(Math.max(r.width,1)/Math.max(y.width,1))),B.push(t.scaleY(Math.max(r.height,1)/Math.max(y.height,1)))),b.opacity&&(j.opacity=_,$.opacity=S);let N=[];if(!l[n]||!l[n].shouldInvert||l[n].shouldInvert(v.previous,v.current)){const t=((t,e)=>s(t.querySelectorAll(`[${d}="${e}"]`)))(A,n);N=t.map(t=>[t,D(t)])}j.matrix=F(B.reduce(t.multiply)),$.matrix=F($.matrix);const L=(({element:t,invertedChildren:i,body:n})=>({matrix:s,opacity:r,forceMinVals:a})=>{if(e(r)&&(t.style.opacity=r+""),a&&(t.style.minHeight="1px",t.style.minWidth="1px"),!s)return;const o=(t=>`matrix(${t.join(", ")})`)(s);t.style.transform=o,i&&(({invertedChildren:t,matrix:e,body:i})=>{t.forEach(([t,n])=>{if(!i.contains(t))return;const s=e[0],r=e[3],a=e[5],o={translateX:0,translateY:0,scaleX:1,scaleY:1};let l="";n.translate&&(o.translateX=-e[4]/s,o.translateY=-a/r,l+=`translate(${o.translateX}px, ${o.translateY}px)`),n.scale&&(o.scaleX=1/s,o.scaleY=1/r,l+=` scale(${o.scaleX}, ${o.scaleY})`),t.style.transform=l})})({invertedChildren:i,matrix:s,body:n})})({element:A,invertedChildren:N,body:O});let q;if(l[n]&&l[n].onComplete){const t=l[n].onComplete;q=()=>t(A,v)}const X=e(j.opacity)&&e($.opacity)&&j.opacity!==$.opacity;let Y=!1;return a({},V,{stagger:U,springConfig:w,getOnUpdateFunc:({spring:t,onAnimationEnd:e})=>(p[n]={destroy:t.destroy.bind(t),onAnimationEnd:e},t=>{l[n]&&l[n].onSpringUpdate&&l[n].onSpringUpdate(t.getCurrentValue()),Y||(Y=!0,l[n]&&l[n].onStart&&l[n].onStart(A,v));const e=t.getCurrentValue();if(!O.contains(A))return void t.destroy();const i={matrix:[]};i.matrix=j.matrix.map((t,i)=>o(t,$.matrix[i],e)),X&&(i.opacity=o(j.opacity,$.opacity,e)),L(i)}),initializeFlip:()=>{L({matrix:j.matrix,opacity:X?j.opacity:void 0,forceMinVals:E}),l[n]&&l[n].onStartImmediate&&l[n].onStartImmediate(A,v),b.transformOrigin?A.style.transformOrigin=b.transformOrigin:g&&(A.style.transformOrigin="0 0"),N.forEach(([t,e])=>{e.transformOrigin?t.style.transformOrigin=e.transformOrigin:g&&(t.style.transformOrigin="0 0")})},onAnimationEnd:t=>{delete p[n],i(q)&&q(),A.style.transform="",N.forEach(([t])=>{t.style.transform=""}),E&&A&&(A.style.minHeight="",A.style.minWidth=""),t||(I.push(n),I.length>=x.length&&C(I))},delayUntil:b.delayUntil})}).filter(Boolean);if(x.forEach(({initializeFlip:t})=>t()),_)return()=>{};const R=x.filter(t=>{return t.delayUntil&&(e=t.delayUntil,x.filter(t=>t.id===e).length);var e}),T={},M={},k={};R.forEach(t=>{t.stagger?(k[t.stagger]=!0,M[t.delayUntil]?M[t.delayUntil].push(t.stagger):M[t.delayUntil]=[t.stagger]):T[t.delayUntil]?T[t.delayUntil].push(t):T[t.delayUntil]=[t]});const $=x.filter(t=>t.stagger).reduce((t,e)=>(t[e.stagger]?t[e.stagger].push(e):t[e.stagger]=[e],t),{}),j=x.filter(t=>-1===R.indexOf(t));return j.forEach(t=>{t.onSpringActivate=()=>{T[t.id]&&T[t.id].forEach(U),M[t.id]&&Object.keys(M[t.id].reduce((t,e)=>a(t,{[e]:!0}),{})).forEach(t=>{V($[t],S[t])})}}),()=>(x.length||C([]),j.filter(t=>!t.stagger).forEach(U),Object.keys($).forEach(t=>{k[t]||V($[t],S[t])}),b)})(X);C?C({hideEnteringElements:N,animateEnteringElements:L,animateExitingElements:q,animateFlippedElements:Y}):(N(),q().then(L),Y())},$=({element:t,flipCallbacks:e={},inProgressAnimations:i={},portalKey:n})=>{const r=T(t,n),o=s(t.querySelectorAll(`[${d}]`)),l={},p=[],h={};r.filter(t=>e&&e[t.dataset.flipId]&&e[t.dataset.flipId].onExit).forEach(t=>{let e=t.parentNode;if(t.closest){const i=t.closest(`[${c}]`);i&&(e=i)}let i=p.findIndex(t=>t[0]===e);-1===i&&(p.push([e,e.getBoundingClientRect()]),i=p.length-1),l[t.dataset.flipId]=p[i][1],h[t.dataset.flipId]=e});const g=M(r),f=g.map(([t,i])=>{const n={};if(e&&e[t.dataset.flipId]&&e[t.dataset.flipId].onExit){const e=l[t.dataset.flipId];a(n,{element:t,parent:h[t.dataset.flipId],childPosition:{top:i.top-e.top,left:i.left-e.left,width:i.width,height:i.height}})}return[t.dataset.flipId,{rect:i,opacity:parseFloat(window.getComputedStyle(t).opacity||"1"),domDataForExitAnimations:n}]}).reduce(R,{});var m,u;return m=i,u=r.concat(o),Object.keys(m).forEach(t=>{m[t].destroy&&m[t].destroy(),m[t].onAnimationEnd&&m[t].onAnimationEnd(!0),delete m[t]}),u.forEach(t=>{t.style.transform="",t.style.opacity=""}),{flippedElementPositions:f,cachedOrderedFlipIds:g.map(([t])=>t.dataset.flipId)}};class j{constructor(t){this.element=void 0,this.staggerConfig=void 0,this.applyTransformOrigin=!0,this.handleEnterUpdateDelete=void 0,this.debug=void 0,this.spring=void 0,this.inProgressAnimations=void 0,this.flipCallbacks=void 0,this.snapshot=void 0,this.onComplete=void 0,this.onStart=void 0,a(this,t),this.inProgressAnimations={},this.flipCallbacks={},this.recordBeforeUpdate=this.recordBeforeUpdate.bind(this),this.update=this.update.bind(this),this.addFlipped=this.addFlipped.bind(this),this.addInverted=this.addInverted.bind(this)}recordBeforeUpdate(){this.snapshot=$({element:this.element,flipCallbacks:this.flipCallbacks,inProgressAnimations:this.inProgressAnimations})}update(t,e){this.snapshot&&(k({flippedElementPositionsBeforeUpdate:this.snapshot.flippedElementPositions,cachedOrderedFlipIds:this.snapshot.cachedOrderedFlipIds,containerEl:this.element,inProgressAnimations:this.inProgressAnimations,flipCallbacks:this.flipCallbacks,applyTransformOrigin:this.applyTransformOrigin,spring:this.spring,debug:this.debug,staggerConfig:this.staggerConfig,handleEnterUpdateDelete:this.handleEnterUpdateDelete,decisionData:{previous:t,current:e},onComplete:this.onComplete,onStart:this.onStart}),delete this.snapshot)}addFlipped({element:t,flipId:e,opacity:i,translate:n,scale:s,transformOrigin:r,spring:o,stagger:l,delayUntil:p,onAppear:d,onStart:h,onSpringUpdate:c,onComplete:g,onExit:f,shouldFlip:m,shouldInvert:u}){if(!t)throw new Error("no element provided");if(!e)throw new Error("No flipId provided");const y={scale:s,translate:n,opacity:i,transformOrigin:r,spring:o,stagger:l,delayUntil:p};y.scale||y.translate||y.opacity||a(y,{translate:!0,scale:!0,opacity:!0}),e&&(t.dataset.flipId=String(e)),t.dataset.flipConfig=JSON.stringify(y),this.flipCallbacks[e]={shouldFlip:m,shouldInvert:u,onAppear:d,onStart:h,onSpringUpdate:c,onComplete:g,onExit:f}}addInverted({element:t,parent:e,opacity:i,translate:n,scale:s,transformOrigin:r}){if(!t)throw new Error("no element provided");if(!e)throw new Error("parent must be provided");const o=e.dataset.flipId,l={scale:s,translate:n,opacity:i,transformOrigin:r};l.scale||l.translate||l.opacity||a(l,{translate:!0,scale:!0,opacity:!0}),t.dataset.inverseFlipId=o,t.dataset.flipConfig=JSON.stringify(l)}}const B=new w,N=({config:t,values:e,onUpdate:i,delay:n=0,onComplete:s})=>{const{stiffness:r,damping:l,overshootClamping:p}=a({},f.noWobble,m(t)),d=B.createSpring(r,l);return d.setOvershootClampingEnabled(!!p),d.addListener({onSpringAtRest:t=>{s&&s(),t.destroy()},onSpringUpdate:t=>{const n=t.getCurrentValue();if(!e)return i(n);const s=Object.keys(e).map(t=>[t,o(e[t][0],e[t][1],n)]).reduce((t,e)=>Object.assign(t,{[e[0]]:e[1]}),{});i(s)}}),n?setTimeout(()=>{d.setEndValue(1)},n):d.setEndValue(1),d};export{j as Flipper,g as constants,$ as getFlippedElementPositionsBeforeUpdate,k as onFlipKeyUpdate,N as spring,l as utilities};
//# sourceMappingURL=index.modern.mjs.map
