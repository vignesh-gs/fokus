import e,{createContext as t,Component as r,Children as n,cloneElement as i}from"react";import"prop-types";import{getFlippedElementPositionsBeforeUpdate as o,onFlipKeyUpdate as p,utilities as l,constants as s,spring as a}from"flip-toolkit";function c(e,t){return(c=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e})(e,t)}function d(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t.indexOf(r=o[n])>=0||(i[r]=e[r]);return i}var f=t({}),u=t("portal"),h=function(t){var r,n;function i(){var e;return(e=t.apply(this,arguments)||this).inProgressAnimations={},e.flipCallbacks={},e.el=void 0,e}n=t,(r=i).prototype=Object.create(n.prototype),r.prototype.constructor=r,c(r,n);var l=i.prototype;return l.getSnapshotBeforeUpdate=function(e){return e.flipKey!==this.props.flipKey&&this.el?o({element:this.el,flipCallbacks:this.flipCallbacks,inProgressAnimations:this.inProgressAnimations,portalKey:this.props.portalKey}):null},l.componentDidUpdate=function(e,t,r){this.props.flipKey!==e.flipKey&&this.el&&p({flippedElementPositionsBeforeUpdate:r.flippedElementPositions,cachedOrderedFlipIds:r.cachedOrderedFlipIds,containerEl:this.el,inProgressAnimations:this.inProgressAnimations,flipCallbacks:this.flipCallbacks,applyTransformOrigin:this.props.applyTransformOrigin,spring:this.props.spring,debug:this.props.debug,portalKey:this.props.portalKey,staggerConfig:this.props.staggerConfig,handleEnterUpdateDelete:this.props.handleEnterUpdateDelete,decisionData:{previous:e.decisionData,current:this.props.decisionData},onComplete:this.props.onComplete,onStart:this.props.onStart})},l.render=function(){var t=this,r=this.props,n=r.portalKey,i=e.createElement(f.Provider,{value:this.flipCallbacks},e.createElement(r.element,{className:r.className,ref:function(e){return t.el=e}},this.props.children));return n&&(i=e.createElement(u.Provider,{value:n},i)),i},i}(r);h.defaultProps={applyTransformOrigin:!0,element:"div"};var m=function(e){var t,r=e.children,o=e.flipId,p=e.inverseFlipId,a=e.portalKey,c=d(e,["children","flipId","inverseFlipId","portalKey"]),f=r,u=function(e){return"function"==typeof e}(f);if(!u)try{f=n.only(r)}catch(e){throw new Error("Each Flipped component must wrap a single child")}c.scale||c.translate||c.opacity||l.assign(c,{translate:!0,scale:!0,opacity:!0});var h=((t={})[s.DATA_FLIP_CONFIG]=JSON.stringify(c),t);return void 0!==o?h[s.DATA_FLIP_ID]=String(o):p&&(h[s.DATA_INVERSE_FLIP_ID]=String(p)),void 0!==a&&(h[s.DATA_PORTAL_KEY]=a),u?f(h):i(f,h)},y=function(t){var r=t.children,n=t.flipId,i=t.shouldFlip,o=t.shouldInvert,p=t.onAppear,s=t.onStart,a=t.onStartImmediate,c=t.onComplete,h=t.onExit,y=t.onSpringUpdate,g=d(t,["children","flipId","shouldFlip","shouldInvert","onAppear","onStart","onStartImmediate","onComplete","onExit","onSpringUpdate"]);return r?g.inverseFlipId?e.createElement(m,Object.assign({},g),r):e.createElement(u.Consumer,null,function(t){return e.createElement(f.Consumer,null,function(d){return l.isObject(d)&&n&&(d[n]={shouldFlip:i,shouldInvert:o,onAppear:p,onStart:s,onStartImmediate:a,onComplete:c,onExit:h,onSpringUpdate:y}),e.createElement(m,Object.assign({flipId:n},g,{portalKey:t}),r)})}):null};y.displayName="Flipped";var g=function(e){var t;return i(e.children,((t={})[s.DATA_EXIT_CONTAINER]=!0,t))};export{g as ExitContainer,y as Flipped,h as Flipper,a as spring};
//# sourceMappingURL=index.es.js.map
